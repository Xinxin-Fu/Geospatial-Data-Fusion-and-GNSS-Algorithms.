#include <iostream>
#include <vector>
#include <cmath>
#include "gdal_priv.h"
#include "cpl_conv.h"

using namespace std;

// 计算均值
float mean(const vector<float>& v) {
    float sum = 0;
    for (float val : v) sum += val;
    return sum / v.size();
}

// PCA 融合的简化实现（仅演示，适合小波段影像）
void PCA_Fusion(vector<float>& R, vector<float>& G, vector<float>& B, const vector<float>& PAN) {
    int size = R.size();

    // 1. 计算均值并中心化
    float meanR = mean(R), meanG = mean(G), meanB = mean(B);
    vector<float> Rc(size), Gc(size), Bc(size);
    for (int i = 0; i < size; i++) {
        Rc[i] = R[i] - meanR;
        Gc[i] = G[i] - meanG;
        Bc[i] = B[i] - meanB;
    }

    // 2. 简单模拟主成分（这里使用均值加权近似）
    vector<float> PC1(size);
    for (int i = 0; i < size; i++) {
        PC1[i] = (Rc[i] + Gc[i] + Bc[i]) / 3.0f;
    }

    // 3. 替换第一主成分为PAN
    float meanPC1 = mean(PC1), meanPAN = mean(PAN);
    vector<float> PC1_new(size);
    for (int i = 0; i < size; i++) {
        PC1_new[i] = PAN[i] - meanPAN + meanPC1; // 保持均值
    }

    // 4. 反变换回RGB（按比例调整）
    for (int i = 0; i < size; i++) {
        float ratio = (PC1_new[i]) / (PC1[i] + 1e-6f); // 防止除零
        R[i] = Rc[i] * ratio + meanR;
        G[i] = Gc[i] * ratio + meanG;
        B[i] = Bc[i] * ratio + meanB;
    }
}

int main() {
    GDALAllRegister();

    // 打开RGB波段和PAN波段
    GDALDataset *R_ds = (GDALDataset*)GDALOpen("B4.tif", GA_ReadOnly);
    GDALDataset *G_ds = (GDALDataset*)GDALOpen("B3.tif", GA_ReadOnly);
    GDALDataset *B_ds = (GDALDataset*)GDALOpen("B2.tif", GA_ReadOnly);
    GDALDataset *PAN_ds = (GDALDataset*)GDALOpen("PAN.tif", GA_ReadOnly);

    if (!R_ds || !G_ds || !B_ds || !PAN_ds) {
        cout << "Error opening input files!" << endl;
        return -1;
    }

    int xSize = R_ds->GetRasterXSize();
    int ySize = R_ds->GetRasterYSize();
    int totalSize = xSize * ySize;

    // 读取波段数据
    vector<float> R(totalSize), G(totalSize), B(totalSize), PAN(totalSize);
    R_ds->GetRasterBand(1)->RasterIO(GF_Read, 0, 0, xSize, ySize, R.data(), xSize, ySize, GDT_Float32, 0, 0);
    G_ds->GetRasterBand(1)->RasterIO(GF_Read, 0, 0, xSize, ySize, G.data(), xSize, ySize, GDT_Float32, 0, 0);
    B_ds->GetRasterBand(1)->RasterIO(GF_Read, 0, 0, xSize, ySize, B.data(), xSize, ySize, GDT_Float32, 0, 0);
    PAN_ds->GetRasterBand(1)->RasterIO(GF_Read, 0, 0, xSize, ySize, PAN.data(), xSize, ySize, GDT_Float32, 0, 0);

    // 执行PCA融合
    PCA_Fusion(R, G, B, PAN);

    // 创建输出文件
    GDALDriver *driver = GetGDALDriverManager()->GetDriverByName("GTiff");
    GDALDataset *R_out = driver->Create("PCA_R.tif", xSize, ySize, 1, GDT_Float32, NULL);
    GDALDataset *G_out = driver->Create("PCA_G.tif", xSize, ySize, 1, GDT_Float32, NULL);
    GDALDataset *B_out = driver->Create("PCA_B.tif", xSize, ySize, 1, GDT_Float32, NULL);

    // 设置投影和仿射
    double geoTransform[6];
    R_ds->GetGeoTransform(geoTransform);
    R_out->SetGeoTransform(geoTransform);
    G_out->SetGeoTransform(geoTransform);
    B_out->SetGeoTransform(geoTransform);

    const char* projection = R_ds->GetProjectionRef();
    R_out->SetProjection(projection);
    G_out->SetProjection(projection);
    B_out->SetProjection(projection);

    // 写入数据
    R_out->GetRasterBand(1)->RasterIO(GF_Write, 0, 0, xSize, ySize, R.data(), xSize, ySize, GDT_Float32, 0, 0);
    G_out->GetRasterBand(1)->RasterIO(GF_Write, 0, 0, xSize, ySize, G.data(), xSize, ySize, GDT_Float32, 0, 0);
    B_out->GetRasterBand(1)->RasterIO(GF_Write, 0, 0, xSize, ySize, B.data(), xSize, ySize, GDT_Float32, 0, 0);

    // 关闭数据集
    GDALClose(R_ds); GDALClose(G_ds); GDALClose(B_ds); GDALClose(PAN_ds);
    GDALClose(R_out); GDALClose(G_out); GDALClose(B_out);

    cout << "PCA fusion completed successfully!" << endl;
    return 0;
}
