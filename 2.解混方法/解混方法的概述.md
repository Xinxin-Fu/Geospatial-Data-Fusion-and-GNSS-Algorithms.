# 基于解混的方法（Unmixing-based methods）

## 方法简介
解混法的核心思路是：一个低分辨率像元往往由多个高分辨率像元混合而成。如果能知道这些高分辨率像元的类别比例（丰度），就可以通过低分辨率观测值来反推每个类别在预测时刻的亮度，再将结果分配回高分辨率像元。

---

## 模拟过程（文字说明）

1. **端元类别**  
   假设高分辨率像元只有两类：植被（V）和土壤（S）。

2. **丰度计算**  
   - LR1 对应的 HR 像元：75% 植被、25% 土壤  
   - LR2 对应的 HR 像元：25% 植被、75% 土壤  

3. **低分辨率观测**  
   在预测时刻 t1，观测到：  
   - LR1 = 0.22  
   - LR2 = 0.28  

4. **解混过程**  
   根据丰度和 LR 值，建立两个方程，求解得到：  
   - 植被在 t1 的亮度 = 0.10  
   - 土壤在 t1 的亮度 = 0.34  

5. **结果分配**  
   将解混结果分配给对应类别的 HR 像元，即可得到 t1 时刻的 HR 亮度分布。

---

## Python 模拟代码

```python
import numpy as np

# 1. 已知条件
# LR1 和 LR2 在 t1 的观测值
LR_t1 = np.array([0.22, 0.28])

# 每个 LR 像元内部类别丰度 (行=类别: V,S; 列=LR1,LR2)
# LR1: 0.75 V, 0.25 S
# LR2: 0.25 V, 0.75 S
F = np.array([
    [0.75, 0.25],  # 植被
    [0.25, 0.75]   # 土壤
])

# 2. 解线性方程 F^T * R = LR
# R 表示 [RV, RS]（植被和土壤的亮度值）
R_t1 = np.linalg.solve(F.T, LR_t1)

print("植被在 t1 的亮度:", R_t1[0])
print("土壤在 t1 的亮度:", R_t1[1])

# 3. 将结果分配给高分辨率像元
# 假设 HR 像元分布如下（0=植被，1=土壤）
HR_classes = np.array([
    [0,0,1,1],  # LR1 内的 HR
    [1,1,0,0]   # LR2 内的 HR
])

HR_reflectance = np.where(HR_classes==0, R_t1[0], R_t1[1])
print("t1 时刻的 HR 亮度分布：")
print(HR_reflectance)
