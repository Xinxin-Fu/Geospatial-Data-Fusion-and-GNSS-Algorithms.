#include <iostream>
#include <vector>
#include <cmath>
#include "gdal_priv.h"
#include "cpl_conv.h"

using namespace std;

// 简单 Haar 小波分解（2x2 块）
void haar2D(const vector<float>& input, vector<float>& cA, vector<float>& cH,
            vector<float>& cV, vector<float>& cD, int width, int height)
{
    int w2 = width / 2;
    int h2 = height / 2;
    cA.resize(w2 * h2);
    cH.resize(w2 * h2);
    cV.resize(w2 * h2);
    cD.resize(w2 * h2);

    for (int y = 0; y < height; y += 2) {
        for (int x = 0; x < width; x += 2) {
            int i = (y / 2) * w2 + (x / 2);
            float a = input[y * width + x];
            float b = input[y * width + (x+1)];
            float c = input[(y+1) * width + x];
            float d = input[(y+1) * width + (x+1)];

            cA[i] = (a + b + c + d) / 4.0f;
            cH[i] = (a + b - c - d) / 4.0f;
            cV[i] = (a - b + c - d) / 4.0f;
            cD[i] = (a - b - c + d) / 4.0f;
        }
    }
}

// Haar 小波逆变换
void iHaar2D(const vector<float>& cA, const vector<float>& cH,
             const vector<float>& cV, const vector<float>& cD,
             vector<float>& output, int width, int height)
{
    int w2 = width / 2;
    int h2 = height / 2;
    output.resize(width * height);

    for (int y = 0; y < height; y += 2) {
        for (int x = 0; x < width; x += 2) {
            int i = (y / 2) * w2 + (x / 2);
            float a = cA[i] + cH[i] + cV[i] + cD[i];
            float b = cA[i] + cH[i] - cV[i] - cD[i];
            float c = cA[i] - cH[i] + cV[i] - cD[i];
            float d = cA[i] - cH[i] - cV[i] + cD[i];

            output[y * width + x] = a;
            output[y * width + (x+1)] = b;
            output[(y+1) * width + x] = c;
            output[(y+1) * width + (x+1)] = d;
        }
    }
}

// 小波融合函数：低频保留MS， 高频用PAN
void waveletFusion(const vector<float>& MS, const vector<float>& PAN,
                   vector<float>& fused, int width, int height)
{
    vector<float> cA_MS, cH_MS, cV_MS, cD_MS;
    vector<float> cA_PAN, cH_PAN, cV_PAN, cD_PAN;

    // 分解
    haar2D(MS, cA_MS, cH_MS, cV_MS, cD_MS, width, height);
    haar2D(PAN, cA_PAN, cH_PAN, cV_PAN, cD_PAN, width, height);

    // 高频用PAN, 低频用MS
    iHaar2D(cA_MS, cH_PAN, cV_PAN, cD_PAN, fused, width, height);
}

int main() {
    GDALAllRegister();

    // 打开RGB波段和PAN波段
    GDALDataset *R_ds = (GDALDataset*)GDALOpen("B4.tif", GA_ReadOnly);
    GDALDataset *G_ds = (GDALDataset*)GDALOpen("B3.tif", GA_ReadOnly);
    GDALDataset *B_ds = (GDALDataset*)GDALOpen("B2.tif", GA_ReadOnly);
    GDALDataset *PAN_ds = (GDALDataset*)GDALOpen("PAN.tif", GA_ReadOnly);

    if (!R_ds || !G_ds || !B_ds || !PAN_ds) {
        cout << "Error opening input files!" << endl;
        return -1;
    }

    int xSize = R_ds->GetRasterXSize();
    int ySize = R_ds->GetRasterYSize();
    int totalSize = xSize * ySize;

    // 读取波段数据
    vector<float> R(totalSize), G(totalSize), B(totalSize), PAN(totalSize);
    R_ds->GetRasterBand(1)->RasterIO(GF_Read, 0, 0, xSize, ySize, R.data(), xSize, ySize, GDT_Float32, 0, 0);
    G_ds->GetRasterBand(1)->RasterIO(GF_Read, 0, 0, xSize, ySize, G.data(), xSize, ySize, GDT_Float32, 0, 0);
    B_ds->GetRasterBand(1)->RasterIO(GF_Read, 0, 0, xSize, ySize, B.data(), xSize, ySize, GDT_Float32, 0, 0);
    PAN_ds->GetRasterBand(1)->RasterIO(GF_Read, 0, 0, xSize, ySize, PAN.data(), xSize, ySize, GDT_Float32, 0, 0);

    // 融合
    vector<float> R_fused, G_fused, B_fused;
    waveletFusion(R, PAN, R_fused, xSize, ySize);
    waveletFusion(G, PAN, G_fused, xSize, ySize);
    waveletFusion(B, PAN, B_fused, xSize, ySize);

    // 创建输出文件
    GDALDriver *driver = GetGDALDriverManager()->GetDriverByName("GTiff");
    GDALDataset *R_out = driver->Create("Wavelet_R.tif", xSize, ySize, 1, GDT_Float32, NULL);
    GDALDataset *G_out = driver->Create("Wavelet_G.tif", xSize, ySize, 1, GDT_Float32, NULL);
    GDALDataset *B_out = driver->Create("Wavelet_B.tif", xSize, ySize, 1, GDT_Float32, NULL);

    // 设置投影和仿射
    double geoTransform[6];
    R_ds->GetGeoTransform(geoTransform);
    R_out->SetGeoTransform(geoTransform);
    G_out->SetGeoTransform(geoTransform);
    B_out->SetGeoTransform(geoTransform);

    const char* projection = R_ds->GetProjectionRef();
    R_out->SetProjection(projection);
    G_out->SetProjection(projection);
    B_out->SetProjection(projection);

    // 写入数据
    R_out->GetRasterBand(1)->RasterIO(GF_Write, 0, 0, xSize, ySize, R_fused.data(), xSize, ySize, GDT_Float32, 0, 0);
    G_out->GetRasterBand(1)->RasterIO(GF_Write, 0, 0, xSize, ySize, G_fused.data(), xSize, ySize, GDT_Float32, 0, 0);
    B_out->GetRasterBand(1)->RasterIO(GF_Write, 0, 0, xSize, ySize, B_fused.data(), xSize, ySize, GDT_Float32, 0, 0);

    // 关闭数据集
    GDALClose(R_ds); GDALClose(G_ds); GDALClose(B_ds); GDALClose(PAN_ds);
    GDALClose(R_out); GDALClose(G_out); GDALClose(B_out);

    cout << "Wavelet fusion completed successfully!" << endl;
    return 0;
}
